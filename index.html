<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fourier</title>
    <link rel="stylesheet" href="style/style.css">
</head>
<body>
    
    <canvas height="1000" width="1000" class="canvas" id="layer1"></canvas>
    <canvas height="1000" width="1000" class="canvas" id="layer2"></canvas>
    <canvas height="1000" width="1000" class="canvas" id="layer3"></canvas>
    <div class="images-list">
        <img 
        onclick="controlImage(0)" 
        src="img/sigma.jpg" 
        class="images">
        <br>
        <img 
        onclick="controlImage(1)" 
        src="img/pi.png" 
        class="images">
        <br>
        <button 
        onclick="controlImage('remove')" 
        class="button-images">Clear</button>
    </div>
    
    <script>
        // Get canvas context
        const images = document.querySelectorAll(".images")
        const canvasLayer1 = document.querySelector("#layer1")
        const canvasLayer2 = document.querySelector("#layer2")
        const canvasLayer3 = document.querySelector("#layer3")
        const ctx = canvasLayer1.getContext('2d')
        const ctx2 = canvasLayer2.getContext('2d')
        const ctx3 = canvasLayer3.getContext('2d')

        // Time of program
        let time = 0
        let circles = {
            /*
            c:{
                control: [2, 1] = 2 + i
                velocity: 1 = 1 circle/s 
            }
            */
        }
        let drawAxies = [
            // [2, 5] = 2 + 5i
        ]  
        let showPoints = true

        class Draw{
            background(activateGrid = true){
                ctx.fillRect(0, 0, 1000, 1000)
                ctx.fillStyle = "black"

                if(activateGrid){

                    let counterX = -5
                    let counterY = 5

                    for(let y = 0; y < 1000; y += 100){
                        ctx.beginPath()
                        ctx.moveTo(0, y)
                        ctx.lineTo(1000, y)
                        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)"
                        ctx.lineWidth = 1
                        ctx.stroke()

                        ctx.font = "20px Arial"
                        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)"
                        ctx.strokeText(`${counterY--} i`, 505, y + 20)
                    }

                    for(let x = 0; x < 1000; x += 100){
                        ctx.beginPath()
                        ctx.moveTo(x, 0)
                        ctx.lineTo(x, 1000)
                        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)"
                        ctx.stroke()

                        ctx.font = "20px Arial"
                        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)"
                        ctx.strokeText(`${counterX++}`, x + 5, 520)
                    }
                }
            }

            circle(x, y, r){
                ctx.beginPath()
                ctx.arc(500 + x * 100, 500 - y * 100, r * 100, 0, 2*Math.PI)
                ctx.strokeStyle = "rgba(25, 255, 255, 0.3)"
                ctx.lineWidth = 2
                ctx.stroke()
            }

            vector(xi, yi, xe, ye){
                ctx.beginPath()
                ctx.moveTo(500 + xi * 100, 500 - yi * 100)
                ctx.lineTo(500 + xe * 100, 500 - ye * 100)
                ctx.lineWidth = 3
                ctx.strokeStyle = "rgba(255, 255, 255, 0.7)"
                ctx.stroke()
            }

            point(x, y){
                ctx2.fillStyle = "rgba(255, 255, 25, 0.8)"
                ctx2.fillRect(500 + x * 100, 500 - y * 100, 3, 3)
            }

            clear(removePoints = false){
                ctx2.clearRect(0, 0, 1000, 1000)
                circles = {}
                if(removePoints){
                    drawAxies = []
                }
            }
        }

        function controlImage(type){
            if(type == 'remove'){
                ctx3.clearRect(0, 0, 1000, 1000)
            }else{
                ctx3.drawImage(images[type], 0, 0) 
            }
        }

        const draw = new Draw()

        function addCircle(control = [1, 0], velocity = 1){

            // Random name
            let randomId = Math.floor(Math.random() * 99999)

            circles[randomId] = {
                control,
                velocity
            }
        }

        function setCircles(circlesLength){

            /*
            VectorsLength - The length of number of circles
            Exemple: -5 = velocity starts -5 to the 5, so 11 circles
            */

            for(
                let initial = circlesLength; 
                initial <= -circlesLength; 
                initial++
            ){
                addCircle([0,0], initial)
            }

            // Number of points and the time's variation
            const numberOfPoints = Object.keys(drawAxies).length
            const dt = 1 / numberOfPoints

            for(const circleId in circles){

                const circle = circles[circleId]

                // Input of function
                let input = 0

                for(const pointId in    drawAxies){
                    // Output of function: [a, bi]
                    const output =    drawAxies[pointId]

                    // e^{term}
                    let term = [
                        Math.cos(-2 * Math.PI * input * circle.velocity),
                        Math.sin(-2 * Math.PI * input * circle.velocity),
                    ]

                    // Calculate Integral
                    circle.control[0] += (output[0] * term[0] + output[1] * term[1] * (-1)) * dt
                    circle.control[1] += (output[0] * term[1] + output[1] * term[0]) * dt

                    // Add time's variation
                    input += dt
                }
                
            }
        }
        
        function render(){
            
            draw.background()

            /*
            Center of circles - [a, bi]
            Complex function - time -> [a, bi]
            
            */
            let center = [0, 0]
            let complexFunc = [0, 0]

            // Sum of each circle
            for(const circleId in circles){

                const circle = circles[circleId]

                // Before modification
                center[0] = complexFunc[0]
                center[1] = complexFunc[1]

                // Initial Circle - time -> [a, bi]
                let initialCircle = [
                    Math.cos(2 * Math.PI * time * circle.velocity),
                    Math.sin(2 * Math.PI * time * circle.velocity) 
                ]
                
                // Sum of circle
                complexFunc[0] += circle.control[0] * initialCircle[0] - circle.control[1] * initialCircle[1]
                complexFunc[1] += circle.control[0] * initialCircle[1] + circle.control[1] * initialCircle[0]
                
                // Draw circle/vector
                draw.circle(
                    center[0], 
                    center[1], 
                    Math.sqrt(Math.pow(circle.control[0], 2) + Math.pow(circle.control[1], 2))
                )
                draw.vector(
                    center[0], 
                    center[1], 
                    complexFunc[0], 
                    complexFunc[1]
                )
                
            }

            // Draw output of function
            draw.point(
                complexFunc[0], 
                complexFunc[1]
            )
            
            if(showPoints){
                for(let pointId in drawAxies){
                    const point = drawAxies[pointId]
                    draw.circle(point[0], point[1], 0.05)
                }
            }
            
            // Add 1 milisecound
            time += 1 / 1000
            
        }

        setInterval(render, 1)

        function getMousePosition(evt){
            let rect = canvasLayer3.getBoundingClientRect()
            return {
                x: ((evt.clientX - rect.left - 10) / 550 * 1000 - 500) / 100,
                y: (500 - (evt.clientY - rect.top -10) / 550 * 1000) / 100,
            }
        }

        canvasLayer3.addEventListener('click', evt => {

            let mousePosition = getMousePosition(evt)
            let randomId = Math.floor(Math.random() * 99999)
            
            drawAxies.push([mousePosition.x, mousePosition.y])
        })

    </script>
</body>
</html>